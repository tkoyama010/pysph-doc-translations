# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013-2018, PySPH developers
# This file is distributed under the same license as the PySPH package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PySPH 1.0b1.dev0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-01 15:35+0000\n"
"PO-Revision-Date: 2021-11-01 15:22+0000\n"
"Language-Team: Japanese (https://www.transifex.com/getfem-doc/teams/127008/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../pysph/docs/source/tutorial/circular_patch.rst:5
msgid "A more detailed tutorial"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:7
msgid ""
"In the previous tutorial (:doc:`circular_patch_simple`) we provided a high "
"level overview of the PySPH framework.  No details were provided on "
"equations, integrators and solvers.  This tutorial assumes that you have "
"read the previous one."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:12
msgid ""
"Recall that in the previous tutorial, a circular patch of fluid with a given"
" initial velocity field was simulated using a weaky-compressible SPH scheme."
" In that example, a ``WCSPHScheme`` object was created in the "
"``create_scheme`` method.  The details of what exactly the scheme does was "
"not discussed.  This tutorial explains some of those details by solving the "
"same problem using a lower-level approach where the actual SPH equations, "
"the integrator, and the solver are created manually.  This should help a "
"user write their own schemes or modify an existing scheme.  The full code "
"for this example can be seen in `elliptical_drop_no_scheme.py "
"<https://github.com/pypr/pysph/tree/master/pysph/examples/elliptical_drop_no_scheme.py>`_."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:24
#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:42
msgid "Imports"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:26
msgid "This example requires a few more imports than the previous case."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:28
msgid "the first several lines are imports of various modules:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:53
msgid ""
"This is common for all examples that do not use a scheme and it is worth "
"noting the pattern of the PySPH imports. Fundamental SPH constructs like the"
" kernel and particle containers are imported from the ``base`` subpackage. "
"The framework related objects like the solver and integrator are imported "
"from the ``solver`` subpackage. Finally, we import from the ``sph`` "
"subpackage, the physics related part for this problem."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:60
msgid ""
"The methods defined for creating the particles are the same as in the "
"previous tutorial with the exception of the call to "
"``self.scheme.setup_properties([pa])``.  In this example, we do not create a"
" scheme, we instead create all the required PySPH objects from the "
"application.  We do not override the ``create_scheme`` method but instead "
"have two other methods called ``create_solver`` and ``create_equations`` "
"which handle this."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:70
#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:230
msgid "Setting up the PySPH framework"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:72
msgid ""
"As we move on, we encounter instantiations of the PySPH framework objects. "
"These are the :py:class:`pysph.solver.application.Application`, "
":py:class:`pysph.sph.integrator.TVDRK3Integrator` and "
":py:class:`pysph.solver.solver.Solver` objects.  The ``create_solver`` "
"method constructs a ``Solver`` instance and returns it as seen below:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:93
msgid ""
"As can be seen, various options are configured for the solver, including "
"initial damping etc."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:98
msgid ""
"Intuitively, in an SPH simulation, the role of the "
":py:class:`EPECIntegrator` should be obvious. In the code, we see that we "
"ask for the \"fluid\" to be stepped using a :py:class:`WCSPHStep` object. "
"Taking a look at the ``create_particles`` method once more, we notice that "
"the **ParticleArray** representing the circular patch was named as `fluid`. "
"So we're essentially asking the PySPH framework to step or *integrate* the "
"properties of the **ParticleArray** fluid using :py:class:`WCSPHStep`. It is"
" safe to assume that the framework takes the responsibility to call this "
"integrator at the appropriate time during a time-step."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:110
msgid ""
"The :py:class:`Solver` is the main driver for the problem. It marshals a "
"simulation and takes the responsibility (through appropriate calls to the "
"integrator) to update the solution to the next time step. It also handles "
"input/output and computing global quantities (such as minimum time step) in "
"parallel."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:117
msgid "Specifying the interactions"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:119
msgid ""
"At this stage, we have the particles (represented by the fluid "
"**ParticleArray**) and the framework to integrate the solution and marshall "
"the simulation. What remains is to define how to actually go about updating "
"properties *within* a time step. That is, for each particle we must \"do "
"something\". This is where the *physics* for the particular problem comes "
"in."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:126
msgid ""
"For SPH, this would be the pairwise interactions between particles. In "
"PySPH, we provide a specific way to define the sequence of interactions "
"which is a *list* of **Equation** objects (see "
":doc:`../reference/equations`). For the circular patch test, the sequence of"
" interactions is relatively straightforward:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:132
msgid "Compute pressure from the Equation of State (EOS):  :math:`p = f(\\rho)`"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:133
msgid "Compute the rate of change of density: :math:`\\frac{d\\rho}{dt}`"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:134
msgid ""
"Compute the rate of change of velocity (accelerations): "
":math:`\\frac{d\\boldsymbol{v}}{dt}`"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:135
msgid ""
"Compute corrections for the velocity (XSPH): "
":math:`\\frac{d\\boldsymbol{x}}{dt}`"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:137
msgid ""
"Care must be taken that the EOS equation should be evaluated for all the "
"particles before the other equations are evaluated."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:143
msgid ""
"We request this in PySPH by creating a list of :py:class:`Equation` "
"instances in the ``create_equations`` method:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:167
msgid ""
"Each ``Group`` instance is completed before the next is taken up.  Each "
"group contains a list of ``Equation`` objects.  Each *interaction* is "
"specified through an :py:class:`Equation` object, which is instantiated with"
" the general syntax:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:176
msgid ""
"The ``dest`` argument specifies the *target* or *destination* "
"**ParticleArray** on which this interaction is going to operate on. "
"Similarly, the ``sources`` argument specifies a *list* of **ParticleArrays**"
" from which the contributions are sought. For some equations like the EOS, "
"it doesn't make sense to define a list of sources and a ``None`` suffices. "
"The specification basically tells PySPH that for one time step of the "
"calculation:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:184
msgid "Use the Tait's EOS to update the properties of the fluid array"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:185
msgid "Compute :math:`\\frac{d\\rho}{dt}` for the fluid from the fluid"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:186
msgid "Compute accelerations for the fluid from the fluid"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:187
msgid "Compute the XSPH corrections for the fluid, using fluid as the source"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:191
msgid ""
"Notice the use of the **ParticleArray** name \"fluid\". It is the "
"responsibility of the user to ensure that the equation specification is done"
" in a manner consistent with the creation of the particles."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:196
msgid ""
"With the list of equations, our problem is completely defined. PySPH now "
"knows what to do with the particles within a time step. More importantly, "
"this information is enough to generate code to carry out a complete SPH "
"simulation.  For more details on how new equations can be written please "
"read :ref:`design_overview`."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:202
msgid "The example may be run the same way as the previous example::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:206
msgid ""
"The resulting output can be analyzed or viewed the same way as in the "
"previous example."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch.rst:209
msgid ""
"In the previous example (:doc:`circular_patch_simple`), the equations and "
"solver are created automatically by the ``WCSPHScheme``. If the "
"``create_scheme`` is overwritten and returns a scheme, the "
"``create_equations`` and ``create_solver`` need not be implemented. For more"
" details on the various application methods, please see "
":py:class:`pysph.solver.application.Application`. Implementing other schemes"
" can be done by either implementing the equations directly as done in this "
"example or one could implement a new :py:class:`pysph.sph.scheme.Scheme`."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:5
msgid "Learning the ropes"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:7
msgid ""
"In the tutorials, we will introduce the PySPH framework in the context of "
"the examples provided. Read this if you are a casual user and want to use "
"the framework *as is*. If you want to add new functions and capabilities to "
"PySPH, you should read :ref:`design_overview`. If you are new to PySPH "
"however, we highly recommend that you go through this document and the next "
"tutorial (:doc:`circular_patch`)."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:14
msgid ""
"Recall that PySPH is a framework for parallel SPH-like simulations in "
"Python. The idea therefore, is to provide a user friendly mechanism to set-"
"up problems while leaving the internal details to the framework. *All* "
"examples follow the following steps:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:22
msgid ""
"The tutorials address each of the steps in this flowchart for problems with "
"increasing complexity."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:25
msgid ""
"The first example we consider is a \"patch\" test for SPH formulations for "
"incompressible fluids in `elliptical_drop_simple.py "
"<https://github.com/pypr/pysph/tree/master/pysph/examples/elliptical_drop_simple.py>`_."
" This problem simulates the evolution of a 2D circular patch of fluid under "
"the influence of an initial velocity field given by:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:31
msgid ""
"u &= -100 x \\\\\n"
"v &= 100 y"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:36
msgid ""
"The kinematical constraint of incompressibility causes the initially "
"circular patch of fluid to deform into an ellipse such that the volume "
"(area) is conserved. An expression can be derived for this deformation which"
" makes it an ideal test to verify codes."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:44
msgid ""
"Taking a look at the example (see `elliptical_drop_simple.py "
"<https://github.com/pypr/pysph/tree/master/pysph/examples/elliptical_drop_simple.py>`_),"
" the first several lines are imports of various modules:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:58
msgid ""
"This is common for most examples and it is worth noting the pattern of the "
"PySPH imports. Fundamental SPH constructs like the kernel and particle "
"containers are imported from the ``base`` subpackage. The framework related "
"objects like the solver and integrator are imported from the ``solver`` "
"subpackage. Finally, we import from the ``sph`` subpackage, the physics "
"related part for this problem."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:65
msgid "The organization of the ``pysph`` package is given below."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:68
msgid "Organization of the ``pysph`` package"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:70
msgid "PySPH is organized into several sub-packages.  These are:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:72
msgid ""
"``pysph.base``: This subpackage defines the "
":py:class:`pysph.base.particle_array.ParticleArray`, the various "
":doc:`../reference/kernels`, the nearest neighbor particle search (NNPS) "
"code, and the Cython code generation utilities."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:77
msgid ""
"``pysph.sph``: Contains the various :doc:`../reference/equations`, the "
":doc:`../reference/integrator` and associated integration steppers, and the "
"code generation for the SPH looping. ``pysph.sph.wc`` contains the equations"
" for the weakly compressible formulation. ``pysph.sph.solid_mech`` contains "
"the equations for solid mechanics and ``pysph.sph.misc`` has miscellaneous "
"equations."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:84
msgid ""
"``pysph.solver``: Provides the :py:class:`pysph.solver.solver.Solver`, the "
":py:class:`pysph.solver.application.Application` and a convenient way to "
"interact with the solver as it is running."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:88
msgid "``pysph.parallel``: Provides the parallel functionality."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:90
msgid ""
"``pysph.tools``: Provides some useful tools including the ``pysph`` script "
"CLI and also the data viewer which is based on Mayavi_."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:93
msgid ""
"``pysph.examples``: Provides many standard SPH examples.  These examples are"
" meant to be extended by users where needed.  This is extremely handy to "
"reproduce and compare SPH schemes."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:100
msgid "Functions for loading/generating the particles"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:102
msgid ""
"The code begins with a few functions related to obtaining the exact solution"
" for the given problem which is used for comparing the computed solution."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:105
msgid ""
"A single new class called ``EllipticalDrop`` which derives from "
":py:class:`pysph.solver.application.Application` is defined. There are "
"several methods implemented on this class:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:109
msgid ""
"``initialize``: lets users specify any parameters of interest relevant to "
"the simulation."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:112
msgid ""
"``create_scheme``: lets the user specify the "
":py:class:`pysph.sph.scheme.Scheme` to use to solve the problem.  Several "
"standard schemes are already available and can be readily used."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:116
msgid ""
"``create_particles``: this method is where one creates the particles to be "
"simulated."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:119
msgid ""
"Of these, ``create_particles`` and ``create_scheme`` are mandatory for "
"without them SPH would be impossible.  The rest (and other methods) are "
"optional.  To see a complete listing of possible methods that one can "
"subclass see :py:class:`pysph.solver.application.Application`."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:124
msgid "The ``create_particles`` method looks like:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:164
msgid ""
"The method is used to initialize the particles in Python. In PySPH, we use a"
" :py:class:`ParticleArray` object as a container for particles of a given "
"*species*. You can think of a particle species as any homogenous entity in a"
" simulation. For example, in a two-phase air water flow, a species could be "
"used to represent each phase. A :py:class:`ParticleArray` can be "
"conveniently created from the command line using NumPy arrays. For example"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:178
msgid ""
"would create a :py:class:`ParticleArray`, representing a uniform "
"distribution of particles on a Cartesian lattice in 2D using the helper "
"function :py:func:`get_particle_array` in the **base** subpackage.  The "
":py:func:`get_particle_array_wcsph` is a special version of this suited to "
"weakly-compressible formulations."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:186
msgid "**ParticleArrays** in PySPH use *flattened* or one-dimensional arrays."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:188
msgid ""
"The :py:class:`ParticleArray` is highly convenient, supporting methods for "
"insertions, deletions and concatenations. In the ``create_particles`` "
"function, we use this convenience to remove a list of particles that fall "
"outside a circular region:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:198
msgid ""
"where, a list of indices is provided. One could also provide the indices in "
"the form of a :py:class:`cyarray.carray.LongArray` which, as the name "
"suggests, is an array of 64 bit integers."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:202
msgid ""
"The particle array also supports what we call strided properties where you "
"may associate multiple values per particle. Normally the stride length is 1."
" This feature is convenient if you wish to associate a matrix or vector of "
"values per particle. You must still access the individual values as a "
"\"flattened\" array but one can resize, remove, and add particles and the "
"strided properties will be honored. For example::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:211
msgid "Will create a new property called ``'A'`` with a stride length of 2."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:215
msgid ""
"Any one-dimensional (NumPy) array is valid input for PySPH. You can generate"
" this from an external program for solid modelling and load it."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:221
msgid ""
"PySPH works with multiple **ParticleArrays**. This is why we actually return"
" a *list* in the last line of the `get_circular_patch` function above."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:225
msgid ""
"The ``create_particles`` always returns a list of particle arrays even if "
"there is only one.  The method ``self.scheme.setup_properties`` "
"automatically adds any properties needed for the particular scheme being "
"used."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:232
msgid ""
"As we move on, we encounter instantiations of the PySPH framework objects. "
"In this example, the :py:class:`pysph.sph.scheme.WCSPH` scheme is created in"
" the ``create_scheme`` method.  The ``WCSPHScheme`` internally creates other"
" basic objects needed for the SPH simulation.  In this case, the scheme "
"instance is passed a list of fluid particle array names and an empty list of"
" solid particle array names.  In this case there are no solid boundaries.  "
"The class is also passed a variety of values relevant to the scheme and "
"simulation.  The kernel to be used is created and passed to the "
"``configure_solver`` method of the scheme.  The "
":py:class:`pysph.sph.integrator.EPECIntegrator` is used to integrate the "
"particle properties.  Various solver related parametes are also setup."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:256
msgid ""
"As can be seen, various options are configured for the solver, including "
"initial damping etc.  The scheme is responsible for:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:259
msgid ""
"setting up the actual equations that describe the interactions between "
"particles (see :doc:`../reference/equations`),"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:262
msgid ""
"setting up the kernel (:doc:`../reference/kernels`) and integrator "
"(:doc:`../reference/integrator`) to use for the simulation. In this case a "
"default cubic spline kernel is used."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:266
msgid ""
"setting up the Solver (:doc:`../reference/solver`), which marshalls the "
"entire simulation."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:269
msgid ""
"For a more detailed introduction to these aspects of PySPH please read, the "
":doc:`circular_patch` tutorial which provides greater detail on these. "
"However, by simply creating the ``WCSPHScheme`` and creating the particles, "
"one can simulate the problem."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:276
msgid ""
"The astute reader may notice that the ``EllipticalDrop`` example is "
"subclassing the :py:class:`Application`.  This makes it easy to pass command"
" line arguments to the solver. It is also important for the seamless "
"parallel execution of the same example. To appreciate the role of the "
":py:class:`Application` consider for a moment how might we write a parallel "
"version of the same example. At some point, we would need some MPI imports "
"and the particles should be created in a distributed fashion. All this (and "
"more) is handled through the abstraction of the :py:class:`Application` "
"which hides all this detail from the user."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:288
msgid "Running the example"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:292
msgid ""
"In the last two lines of the example, we instantiate the ``EllipticalDrop`` "
"class and run it:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:301
msgid ""
"The :py:class:`Application` takes care of creating the particles, creating "
"the solver, handling command line arguments etc.  Many parameters can be "
"configured via the command line, and these will override any parameters "
"setup in the respective ``create_*`` methods.  For example one may do the "
"following to find out the various options::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:309
msgid ""
"If we run the example without any arguments it will run until a final time "
"of 0.0075 seconds.  We can change this example to 0.005 by the following::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:315
msgid ""
"When this is run, PySPH will generate Cython code from the equations and "
"integrators that have been provided, compiles that code and runs the "
"simulation.  This provides a great deal of convenience for the user without "
"sacrificing performance.  The generated code is available in "
"``~/.pysph/source``.  If the code/equations have not changed, then the code "
"will not be recompiled.  This is all handled automatically without user "
"intervention.  By default, output files will be generated in the directory "
"``elliptical_drop_output``."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:324
msgid "If we wish to utilize multiple cores we could do::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:328
msgid ""
"If we wish to run the code in parallel (and have compiled PySPH with Zoltan_"
" and mpi4py_) we can do::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:333
msgid ""
"This will automatically parallelize the run using 4 processors. In this "
"example doing this will only slow it down as the number of particles is "
"extremely small."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:338
msgid "Visualizing and post-processing"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:340
msgid ""
"You can view the data generated by the simulation (after the simulation is "
"complete or during the simulation) by running the ``pysph view`` command.  "
"To view the simulated data you may do::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:346
msgid "If you have Mayavi_ installed this should show a UI that looks like:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rstNone
msgid "PySPH viewer"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:352
msgid "For more help on the viewer, please run::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:361
msgid ""
"On the user interface, the right side shows the visualized data.  On top of "
"it there are several toolbar icons.  The left most is the Mayavi logo and "
"clicking on it will present the full Mayavi user interface that can be used "
"to configure any additional details of the visualization."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:366
msgid ""
"On the bottom left of the main visualization UI there is a button which has "
"the text \"Launch Python Shell\".  If one clicks on this, one obtains a full"
" Python interpreter with a few useful objects available.  These are::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:376
msgid ""
"The ``particle_arrays`` object is a dictionary of **ParticleArrayHelpers** "
"which is available in "
":py:class:`pysph.tools.mayavi_viewer.ParticleArrayHelper`. The "
"``interpolator`` is an instance of "
":py:class:`pysph.tools.mayavi_viewer.InterpolatorView` that is used by the "
"viewer. The other objects can be used to script the user interface if "
"desired. Note that the ``particle_arrays`` can be indexed by array name or "
"index."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:384
msgid ""
"Here is an example of scripting the viewer. Let us say we have two particle "
"arrays, `'boundary'` and `'fluid'` in that order. Let us say, we wish to "
"make the boundary translucent, then we can write the following::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:391
msgid ""
"This does require some knowledge of Mayavi_ and scripting with it. The "
"`plot` attribute of the "
":py:class:`pysph.tools.mayavi_viewer.ParticleArrayHelper` is a `Glyph` "
"instance from Mayavi_. It is useful to use the `record feature "
"<http://docs.enthought.com/mayavi/mayavi/mlab_changing_object_looks.html"
"#changing-object-properties-interactively>`_ of Mayavi to learn more about "
"how best to script the view."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:397
msgid ""
"The viewer will always look for a ``mayavi_config.py`` script inside the "
"output directory to setup the visualization parameters. This file can be "
"created by overriding the :py:class:`pysph.solver.application.Application` "
"object's ``customize_output`` method. See the `dam break 3d "
"<https://github.com/pypr/pysph/blob/master/pysph/examples/dam_break_3d.py>`_"
" example to see this being used. Of course, this file can also be created "
"manually."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:407
msgid "Loading output data files"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:409
msgid ""
"The simulation data is dumped out either in ``*.hdf5`` files (if one has "
"h5py_ installed) or ``*.npz`` files otherwise. You may use the "
":py:func:`pysph.solver.utils.load` function to access the raw data ::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:418
msgid ""
"When opening the saved file with ``load``, a dictionary object is returned. "
"The particle arrays and other information can be obtained from this "
"dictionary::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:425
msgid ""
"``particle_arrays`` is a dictionary of all the PySPH particle arrays. You "
"may obtain the PySPH particle array, ``fluid``, like so::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:431
msgid ""
"``p`` is a numpy array containing the pressure values.  All the saved "
"particle array properties can thus be obtained and used for any post-"
"processing task. The ``solver_data`` provides information about the "
"iteration count, timestep and the current time."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:436
msgid ""
"A good example that demonstrates the use of these is available in the "
"``post_process`` method of the ``elliptical_drop.py`` example."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:443
msgid "Interpolating properties"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:445
msgid ""
"Data from the solver can also be interpolated using the "
":py:class:`pysph.tools.interpolator.Interpolator` class.  Here is the "
"simplest example of interpolating data from the results of a simulation onto"
" a fixed grid that is automatically computed from the known particle "
"arrays::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:457
msgid ""
"``p`` is now a numpy array of size 10000 elements shaped such that it "
"interpolates all the data in the particle arrays loaded.  ``interp.x`` and "
"``interp.y`` are numpy arrays of the chosen ``x`` and ``y`` coordinates "
"corresponding to ``p``.  To visualize this we may simply do::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:465
msgid ""
"It is easy to interpolate any other property too.  If one wishes to "
"explicitly set the domain on which the interpolation is required one may "
"do::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:472
msgid ""
"This will create a meshgrid in the specified region with the specified "
"number of points."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:475
msgid ""
"One could also explicitly set the points on which one wishes to interpolate "
"the data as::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:480
msgid ""
"Where ``x, y, z`` are numpy arrays of the coordinates of the points on which"
" the interpolation is desired.  This can also be done with the constructor "
"as::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:485
msgid ""
"There are some cases, where one may require a higher order interpolation or "
"gradient approximation of the property. This can be done by passing a "
"``method`` for interpolation to the interplator as::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:491
msgid ""
"Currently, PySPH has three method of interpolation namely ``shepard``, "
"``sph`` and ``order1``. When ``order1`` is set as method then one can get "
"the higher order interpolation or it's derivative by just passing an extra "
"argument to the interpolate method suggesting the component. To get "
"derivative in `x` we can do as::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:499
msgid ""
"Here for `comp=0`, the interpolated property is returned and `1`, `2`, `3` "
"will return gradient in `x`, `y` and `z` directions respectively."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:502
msgid ""
"For more details on the class and the available methods, see "
":py:class:`pysph.tools.interpolator.Interpolator`."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:505
msgid ""
"In addition to this there are other useful pre and post-processing utilities"
" described in :doc:`../reference/tools`."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:509
msgid "Viewing the data in an IPython notebook"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:511
msgid ""
"PySPH makes it relatively easy to view the data inside an IPython notebook "
"with minimal additional dependencies. A simple UI is provided to view the "
"saved data using this interface. It requires jupyter_,  ipywidgets_ and "
"ipympl_. Currently, a 2D and 3D viewer are provided for the data. Here is a "
"simple example of how one may use this in a notebook. Inside a notebook, one"
" needs the following::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:522
msgid "The ``viewer`` has many useful methods::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:528
msgid "The most handy one is the one to perform interactive plots::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:532
msgid ""
"This shows a simple ipywidgets_ based UI that uses matplotlib to plot the "
"data on the browser. The different saved snapshots can be viewed using a "
"convenient slider. The viewer shows both the particles as well as simple "
"vector plots. This is convenient when one wishes to share and show the data "
"without requiring Mayavi. It does require pysph to be installed in order to "
"be able to load the files. It is mandatory to have the first line that sets "
"the matplotlib backend to ``ipympl``."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:540
msgid ""
"There is also a 3D viewer which may be used using ``Viewer3D`` instead of "
"the ``Viewer2D`` above.  This viewer requires ipyvolume_ to be installed."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:551
msgid "A slightly more complex example"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:553
msgid ""
"The first example was very simple. In particular there was no post-"
"processing of the results. Many pysph examples also include post processing "
"code in the example. This makes it easy to reproduce results and also easily"
" compare different schemes. A complete version of the elliptical drop "
"example is available at `elliptical_drop.py "
"<https://github.com/pypr/pysph/tree/master/pysph/examples/elliptical_drop.py>`_."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:560
msgid "There are a few things that this example does a bit differently:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:562
msgid "It some useful code to generate the exact solution for comparison."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:564
msgid ""
"It uses a ``Gaussian`` kernel and also uses a variety of different options "
"for the solver (see how the ``configure_solver`` is called) for various "
"other options see :py:class:`pysph.solver.solver.Solver`."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:568
msgid ""
"The ``EllipticalDrop`` class has a ``post_process`` method which optionally "
"post-process the results generated. This in turn uses a couple of private "
"methods ``_compute_results`` and ``_make_final_plot``."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:572
msgid ""
"The last line of the code has a call to ``app.post_process(...)``, which "
"actually post-processes the data."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:575
msgid ""
"This example is therefore a complete example and shows how one could write a"
" useful and re-usable PySPH example."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:580
msgid "Doing more"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:584
msgid ""
"The :py:class:`Application` has several more methods that can be used in "
"additional contexts, for example one may override the following additional "
"methods:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:588
msgid ""
"``add_user_options``: this is used to create additional user-defined command"
" line arguments.  The command line options are available in ``self.options``"
" and can be used in the other methods."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:592
msgid ""
"``consume_user_options``: this is called after the command line arguments "
"are parsed, and can be optionally used to setup any variables that have been"
" added by the user in ``add_user_options``.  Note that the method is called "
"before the particles and solver etc. are created."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:597
msgid "``create_domain``: this is used when a periodic domain is needed."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:599
msgid ""
"``create_inlet_outlet``:  Override this to return any inlet an outlet "
"objects.  See the :py:class:`pysph.sph.simple_inlet_outlet` module."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:602
msgid ""
"There are many others, please see the :py:class:`Application` class "
"documentation to see these. The order of invocation of the various methods "
"is also documented there."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:606
msgid ""
"There are several `examples "
"<https://github.com/pypr/pysph/tree/master/pysph/examples/>`_ that ship with"
" PySPH, explore these to get a better idea of what is possible."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:612
msgid "Debugging when things go wrong"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:614
msgid ""
"When you attempt to run your own simulations you may run into a variety of "
"errors. Some errors in setting up equations and the like are easy to detect "
"and PySPH will provide an error message that should usually be helpful. If "
"this is a Python related error you should get a traceback and debug it as "
"you would debug any Python program."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:620
msgid ""
"PySPH writes out a log file in the output directory, looking at that is "
"sometimes useful. The log file will usually tell you the kernel, integrator,"
" NNPS, and the exact equations and groups used for a simulation. This can be"
" often be very useful when sorting out subtle issues with the equations and "
"groups."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:626
msgid ""
"Things get harder to debug when you get a segmentation fault or your code "
"just crashes. Even though PySPH is implemented in Python you can get one of "
"these if your timestep is too large or your equations are doing strange "
"things (divide by zero, taking a square root of a negative number). This "
"happens because PySPH translates your code into a lower-level language for "
"performance.  The following are the most common causes of a crash/segfault:"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:633
msgid ""
"The particles have \"blown up\", this can happen when the accelerations are "
"very large.  This can also happen when your timestep is very large."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:635
msgid ""
"There are mistakes in your equations or integrator step. Divide by zero, or "
"some quantity was not properly initialized -- for example if the particle "
"masses were not correctly initialized and were set to zero you might get "
"these errors. It is also possible that you have made some indexing errors in"
" your arrays, check all your array accesses in your equations."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:642
msgid ""
"Let us see how we can debug these. Let us say your code is in "
"``example.py``, you can do the following::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:647
msgid ""
"In this case, the ``--pfreq 1`` asks pysph to dump output at every timestep."
" By default only specific properties that the user has requested are saved. "
"Using ``--detailed-output`` dumps every property of every array. This "
"includes all accelerations as well. Viewing this data with the ``pysph "
"view`` command makes it easy to see which acceleration is causing a problem."
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:653
msgid ""
"Sometimes even this is not enough as the particles diverge or the code blows"
" up at the very first step of a multi-stage integrator. In this case, no "
"output would be generated. To debug the accelerations in this situation one "
"may define a method called ``pre_step`` in your "
":py:class:`pysph.solver.application.Application` subclass as follows::"
msgstr ""

#: ../../pysph/docs/source/tutorial/circular_patch_simple.rst:665
msgid ""
"What this does is to ask the solver to dump the output right before each "
"timestep is taken. At the start of the simulations the first accelerations "
"have been calculated and since this output is now saved, one should be able "
"to debug the accelerations. Again, use ``--detailed-output`` with this to "
"look at the accelerations right at the start."
msgstr ""
